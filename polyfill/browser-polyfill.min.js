"use strict";if(typeof browser==="undefined"||Object.getPrototypeOf(browser)!==Object.prototype){const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE="The message port closed before a response was received.";const SEND_RESPONSE_DEPRECATION_WARNING="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)";const wrapAPIs=extensionAPIs=>{const apiMetadata={};if(Object.keys(apiMetadata).length===0){throw new Error("api-metadata.json has not been included in browser-polyfill")}
class DefaultWeakMap extends WeakMap{constructor(createItem,items=undefined){super(items);this.createItem=createItem}
get(key){if(!this.has(key)){this.set(key,this.createItem(key))}
return super.get(key)}}
const isThenable=value=>{return value&&typeof value==="object"&&typeof value.then==="function"};const makeCallback=(promise,metadata)=>{return(...callbackArgs)=>{if(extensionAPIs.runtime.lastError){promise.reject(extensionAPIs.runtime.lastError)}else if(metadata.singleCallbackArg||(callbackArgs.length<=1&&metadata.singleCallbackArg!==!1)){promise.resolve(callbackArgs[0])}else{promise.resolve(callbackArgs)}}};const pluralizeArguments=(numArgs)=>numArgs==1?"argument":"arguments";const wrapAsyncFunction=(name,metadata)=>{return function asyncFunctionWrapper(target,...args){if(args.length<metadata.minArgs){throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`)}
if(args.length>metadata.maxArgs){throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`)}
return new Promise((resolve,reject)=>{if(metadata.fallbackToNoCallback){try{target[name](...args,makeCallback({resolve,reject},metadata))}catch(cbError){console.warn(`${name} API method doesn't seem to support the callback parameter, `+"falling back to call it without a callback: ",cbError);target[name](...args);metadata.fallbackToNoCallback=!1;metadata.noCallback=!0;resolve()}}else if(metadata.noCallback){target[name](...args);resolve()}else{target[name](...args,makeCallback({resolve,reject},metadata))}})}};const wrapMethod=(target,method,wrapper)=>{return new Proxy(method,{apply(targetMethod,thisObj,args){return wrapper.call(thisObj,target,...args)},})};let hasOwnProperty=Function.call.bind(Object.prototype.hasOwnProperty);const wrapObject=(target,wrappers={},metadata={})=>{let cache=Object.create(null);let handlers={has(proxyTarget,prop){return prop in target||prop in cache},get(proxyTarget,prop,receiver){if(prop in cache){return cache[prop]}
if(!(prop in target)){return undefined}
let value=target[prop];if(typeof value==="function"){if(typeof wrappers[prop]==="function"){value=wrapMethod(target,target[prop],wrappers[prop])}else if(hasOwnProperty(metadata,prop)){let wrapper=wrapAsyncFunction(prop,metadata[prop]);value=wrapMethod(target,target[prop],wrapper)}else{value=value.bind(target)}}else if(typeof value==="object"&&value!==null&&(hasOwnProperty(wrappers,prop)||hasOwnProperty(metadata,prop))){value=wrapObject(value,wrappers[prop],metadata[prop])}else if(hasOwnProperty(metadata,"*")){value=wrapObject(value,wrappers[prop],metadata["*"])}else{Object.defineProperty(cache,prop,{configurable:!0,enumerable:!0,get(){return target[prop]},set(value){target[prop]=value},});return value}
cache[prop]=value;return value},set(proxyTarget,prop,value,receiver){if(prop in cache){cache[prop]=value}else{target[prop]=value}
return!0},defineProperty(proxyTarget,prop,desc){return Reflect.defineProperty(cache,prop,desc)},deleteProperty(proxyTarget,prop){return Reflect.deleteProperty(cache,prop)},};let proxyTarget=Object.create(target);return new Proxy(proxyTarget,handlers)};const wrapEvent=wrapperMap=>({addListener(target,listener,...args){target.addListener(wrapperMap.get(listener),...args)},hasListener(target,listener){return target.hasListener(wrapperMap.get(listener))},removeListener(target,listener){target.removeListener(wrapperMap.get(listener))},});let loggedSendResponseDeprecationWarning=!1;const onMessageWrappers=new DefaultWeakMap(listener=>{if(typeof listener!=="function"){return listener}
return function onMessage(message,sender,sendResponse){let didCallSendResponse=!1;let wrappedSendResponse;let sendResponsePromise=new Promise(resolve=>{wrappedSendResponse=function(response){if(!loggedSendResponseDeprecationWarning){console.warn(SEND_RESPONSE_DEPRECATION_WARNING,new Error().stack);loggedSendResponseDeprecationWarning=!0}
didCallSendResponse=!0;resolve(response)}});let result;try{result=listener(message,sender,wrappedSendResponse)}catch(err){result=Promise.reject(err)}
const isResultThenable=result!==!0&&isThenable(result);if(result!==!0&&!isResultThenable&&!didCallSendResponse){return!1}
const sendPromisedResult=(promise)=>{promise.then(msg=>{sendResponse(msg)},error=>{let message;if(error&&(error instanceof Error||typeof error.message==="string")){message=error.message}else{message="An unexpected error occurred"}
sendResponse({__mozWebExtensionPolyfillReject__:!0,message,})}).catch(err=>{console.error("Failed to send onMessage rejected reply",err)})};if(isResultThenable){sendPromisedResult(result)}else{sendPromisedResult(sendResponsePromise)}
return!0}});const wrappedSendMessageCallback=({reject,resolve},reply)=>{if(extensionAPIs.runtime.lastError){if(extensionAPIs.runtime.lastError.message===CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE){resolve()}else{reject(extensionAPIs.runtime.lastError)}}else if(reply&&reply.__mozWebExtensionPolyfillReject__){reject(new Error(reply.message))}else{resolve(reply)}};const wrappedSendMessage=(name,metadata,apiNamespaceObj,...args)=>{if(args.length<metadata.minArgs){throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`)}
if(args.length>metadata.maxArgs){throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`)}
return new Promise((resolve,reject)=>{const wrappedCb=wrappedSendMessageCallback.bind(null,{resolve,reject});args.push(wrappedCb);apiNamespaceObj.sendMessage(...args)})};const staticWrappers={runtime:{onMessage:wrapEvent(onMessageWrappers),onMessageExternal:wrapEvent(onMessageWrappers),sendMessage:wrappedSendMessage.bind(null,"sendMessage",{minArgs:1,maxArgs:3}),},tabs:{sendMessage:wrappedSendMessage.bind(null,"sendMessage",{minArgs:2,maxArgs:3}),},};const settingMetadata={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1},};apiMetadata.privacy={network:{"*":settingMetadata},services:{"*":settingMetadata},websites:{"*":settingMetadata},};return wrapObject(extensionAPIs,staticWrappers,apiMetadata)};if(typeof chrome!="object"||!chrome||!chrome.runtime||!chrome.runtime.id){throw new Error("This script should only be loaded in a browser extension.")}
module.exports=wrapAPIs(chrome)}else{module.exports=browser}

// webextension-polyfill v.0.6.0 (https://github.com/mozilla/webextension-polyfill)

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
